//: Playground - noun: a place where people can play

import UIKit

//运算符是检查、改变、合并值的特殊符号或短语。例如，加号( + )将两个数相加(如 let i = 1 + 2 )。更复 杂的运算例子包括逻辑与运算符 && (如 if enteredDoorCode && passedRetinaScan )。

//术语
/*
 运算符分为一元、二元和三元运算符:
 • 一元运算符对单一操作对象操作(如 -a )。一元运算符分前置运算符和后置运算符，前置运算符需紧跟在 操作对象之前(如 !b )，后置运算符需紧跟在操作对象之后(如 c! )。
 • 二元运算符操作两个操作对象(如 2 + 3 )，是中置的，因为它们出现在两个操作对象之间。
 • 三元运算符操作三个操作对象，和 C 语言一样，Swift 只有一个三元运算符，就是三目运算符( a ? b :
 c)。
 受运算符影响的值叫操作数，在表达式 1 + 2 中，加号 + 是二元运算符，它的两个操作数是值 1 和 2 。
 */

//赋值运算符
//赋值运算符( a = b )，表示用 b 的值来初始化或更新 a 的值:

let b = 10
var a = 5
a = b
// a 现在等于 10

//如果赋值的右边是一个多元组，它的元素可以马上被分解成多个常量或变量:
let (x, y) = (1, 2)
// 现在 x 等于 1，y 等于 2

//与 C 语言和 Objective-C 不同，Swift 的赋值操作并不返回任何值。所以以下代码是错误的:

/*
if x = y {
    // 此句错误, 因为 x = y 并不返回任何值
}
 */

//这个特性使你无法把( == )错写成( = )，由于 if x = y 是错误代码，Swift 能帮你避免此类错误发生。

//算术运算符

//Swift 中所有数值类型都支持了基本的四则算术运算符:
/*
 • 加法(+) 
 • 减法(-)
 • 乘法(*)
 • 除法(/)
 */

//与 C 语言和 Objective-C 不同的是，Swift 默认情况下不允许在数值运算中出现溢出情况。但是你可以使用 Swift 的溢出运算符来实现溢出运算(如 a &+ b )

//加法运算符也可用于 String 的拼接: "hello, " + "world" // 等于 "hello, world"

//求余运算符 求余运算符( a % b )是计算 b 的多少倍刚刚好可以容入 a ，返回多出来的那部分(余数)。
//注意: 求余运算符( % )在其他语言也叫取模运算符。然而严格说来，我们看该运算符对负数的操作结果，「求余」比「取模」更合适些。

9 % 4
-9 % 4
9 % -4

//在对负数 b 求余时， b 的符号会被忽略。这意味着 a % b 和 a % -b 的结果是相同的。

//一元负号运算符 数值的正负号可以使用前缀 - (即一元负号符)来切换:
let three = 3
let minusThree = -three // minusThree 等于 -3
let plusThree = -minusThree // plusThree 等于 3, 或 "负负3"

//一元负号符( - )写在操作数之前，中间没有空格。

//一元正号运算符 一元正号符( + )不做任何改变地返回操作数的值: 
let minusSix = -6
let alsoMinusSix = +minusSix // alsoMinusSix 等于 -6

//虽然一元正号符什么都不会改变，但当你在使用一元负号来表达负数时，你可以使用一元正号来表达正数，如此你的代码会具有对称美。

//组合赋值运算符
//如同 C 语言，Swift 也提供把其他运算符和赋值运算( = )组合的组合赋值运算符，组合加运算( += )是其中 一个例子:
var anotherA = 1
anotherA += 2
// anotherA 现在是 3
//表达式 a += 2 是 a = a + 2 的简写，一个组合加运算就是把加法运算和赋值运算组合成进一个运算符里，同 时完成两个运算任务。

/*
 注意:
 复合赋值运算没有返回值， let b = a += 2 这类代码是错误。这不同于上面提到的自增和自减运算符。
 */

//比较运算符
/*
 所有标准 C 语言中的比较运算符都可以在 Swift 中使用:
 • 等于( a == b )
 • 不等于( a != b )
 • 大于( a > b )
 • 小于( a < b )
 • 大于等于( a >= b )
 • 小于等于( a <= b )
 */

//注意: Swift 也提供恒等( === )和不恒等( !== )这两个比较符来判断两个对象是否引用同一个对象实例。

//每个比较运算都返回了一个标识表达式是否成立的布尔值:
1 == 1
2 != 1
2 > 1
1 < 2
1 >= 1
2 <= 1
// true, 因为 1 等于 1
// true, 因为 2 不等于 1
// true, 因为 2 大于 1
// true, 因为 1 小于2
// true, 因为 1 大于等于 1
// false, 因为 2 并不小于等于 1
//比较运算多用于条件语句，如 if 条件:
let name = "world"
if name == "world" {
    print("hello, world")
} else {
    print("I'm sorry \(name), but I don't recognize you")
}
// 输出 "hello, world", 因为 `name` 就是等于 "world"

//当元组中的值可以比较时，你也可以使用这些运算符来比较它们的大小。例如，因为 Int 和 String 类型的值 可以比较，所以类型为 (Int, String) 的元组也可以被比较。相反， Bool不能被比较，也意味着存有布尔类型的元组不能被比较。

//比较元组大小会按照从左到右、逐值比较的方式，直到发现有两个值不等时停止。如果所有的值都相等，那么这一对元组我们就称它们是相等的
(1, "zebra") < (2, "apple")// true，因为 1 小于 2
(3, "apple") < (3, "bird")// true，因为 3 等于 3，但是 apple 小于 bird
(4, "dog") == (4, "dog")// true，因为 4 等于 4，dog 等于 dog

//在上面的例子中，你可以看到，在第一行中从左到右的比较行为。因为 1 小于 2 ，所以 (1, "zebra") 小于 (2, "apple") ，不管元组剩下的值如何。所以 "zebra" 小于 "apple" 没有任何影响，因为元组的比较已经被第一个元 素决定了。不过，当元组的第一个元素相同时候，第二个元素将会用作比较-第二行和第三行代码就发生了这样的 比较。

/*
 注意:
 Swift 标准库只能比较七个以内元素的元组比较函数。如果你的元组元素超过七个时，你需要自己实现比较运算 符。
 */

//三目运算符
//三目运算符的特殊在于它是有三个操作数的运算符，它的形式是 问题 ? 答案 1 : 答案 2 。它简洁地表达根据问题 成立与否作出二选一的操作。如果 问题 成立，返回 答案 1 的结果;反之返回 答案 2 的结果。 三目运算符是以下代码的缩写形式:

/*
if question {
    answer1
} else {
    answer2
}
*/

//这里有个计算表格行高的例子。如果有表头，那行高应比内容高度要高出 50 点;如果没有表头，只需高出 20 点:
let contentHeight = 40
let hasHeader = true
let rowHeight = contentHeight + (hasHeader ? 50 : 20) // rowHeight 现在是 90

//需要注意的事，过度使用三目运算符会使简洁的代码变的难懂。我们应避免在一个组合语句中使用多个三目运算符。

//空合运算符 空合运算符(a??b)将对可选类型a进行空判断，如果a包含一个值就进行解封，否则就返回一个默认值b。表达式a必须是Optional类型 默认值b的类型必须要和a存储值的类型保持一致。
//空合运算符是对以下代码的简短表达方法:
var optionalInt: Int?
var confirmInt = 2017
optionalInt != nil ? optionalInt! : confirmInt//?与nil间隔一个空格

//当可选类型 a 的值不为空时，进行强制解封(a!)，访问 a 中的值;反之返 回默认值 b 。无疑空合运算符( ?? )提供了一种更为优雅的方式去封装条件判断和解封两种行为，显得简洁以 及更具可读性。

//注意: 如果 a 为非空值( non-nil )，那么值 b 将不会被计算。这也就是所谓的短路求值。

//采用空合运算符，实现了在默认颜色名和可选自定义颜色名之间抉择:
let defaultColorName = "red"
var userDefinedColorName: String? //默认值为 nil
var colorNameToUse = userDefinedColorName ?? defaultColorName
// userDefinedColorName 的值为空，所以 colorNameToUse 的值为 "red"

//区间运算符 Swift 提供了两个方便表达一个区间的值的区间运算符。

//闭区间运算符 闭区间运算符(a...b)定义一个包含从a到b(包括a和b)的所有值的区间。 a的值不能超过b。 闭区间运算符在迭代一个区间的所有值时是非常有用的
for index in 1...5 {
    print("\(index) * 5 = \(index * 5)")
}

//半开区间运算符 半开区间运算符(a..<b)定义一个从a到b但不包括b的区间。包含第一个值而不包括最后的值。
//半开区间的实用性在于当你使用一个从 0 开始的列表(如数组)时，非常方便地从0数到列表的长度
var names = ["Tom", "Lucy", "Alice"]
let count = names.count
for i in 0..<count {
    print("第\(i + 1)个人的名字是\(names[i])")
}

//逻辑运算符 逻辑运算符的操作对象是逻辑布尔值。Swift 支持基于 C 语言的三个标准逻辑运算
/*
 
 •逻辑非(!a)
 • 逻辑与(a && b)
 • 逻辑或(a || b)
 */

//逻辑非运算符 逻辑非运算符( !a )对一个布尔值取反，使得 true 变 false ， false 变 true 。
//它是一个前置运算符，需紧跟在操作数之前，且不加空格。读作 非 a

//逻辑与运算符 逻辑与运算符( a && b )表达了只有 a 和 b 的值都为 true 时，整个表达式的值才会是 true 。
//只要任意一个值为 false ，整个表达式的值就为 false 。事实上，如果第一个值为 false ，那么是不去计算第二个值的，因为它已经不可能影响整个表达式的结果了。这被称做短路计算(short-circuit evaluation)。

//逻辑或运算符 逻辑或运算符( a || b )是一个由两个连续的 | 组成的中置运算符。它表示了两个逻辑表达式的其中一个为 true ，整个表达式就为 true 。
//同逻辑与运算符类似，逻辑或也是「短路计算」的，当左端的表达式为 true 时，将不计算右边的表达式了，因 为它不可能改变整个表达式的值了。

//逻辑运算符组合计算

//注意: Swift 逻辑操作符 && 和 || 是左结合的，这意味着拥有多元逻辑操作符的复合表达式优先计算最左边的子表达式。

//使用括号来明确优先级 为了一个复杂表达式更容易读懂，在合适的地方使用括号来明确优先级是很有效的，虽然它并非必要的
